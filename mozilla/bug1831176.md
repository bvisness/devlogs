# Kotlin br_on_cast_fail types (bug 1843633)

I don't think this is the actual source of the problem, but let's work through it:

block (result (ref null struct))
    local.get $3_IS_INTERFACE_PARAMETER
    struct.get $kotlin.Any___type_130 1 ;; type (ref null struct)
    ;; original: br_on_cast_fail 1 0 struct $classITable___type_141
    br_on_cast_fail 0 (ref null struct) (ref $classITable___type_141)
    struct.get $classITable___type_141 4
    ref.is_null
    i32.eqz
    br 1
end

br_on_cast_fail
  flags = 1 (0b01, source nullable, dest not nullable)
  label = 0
  source type = struct
  dest type = $classITable___type_141

(type $kotlin.Any___type_130 (struct
  (field (ref $kotlin.Any.vtable___type_112))
  (field (ref null struct))
  (field (mut i32))
  (field (mut i32))))

The source type checks out; branching on cast failure also checks out with the block's result type. All good here. Let's find the actual problem.


The full message is:

at offset 113975: type mismatch: expression has type structref but expected (ref null 142)

Offset 113975 is 0x1BD37. This indeed is just after an fb4f instruction (br_on_cast_fail), so we seem to be in the right place. Now, how to figure out what function this corresponds to in the text format...

Well, it seems like the byte immediately following is 0xFB, so a block end. That's kind of strange, to have that immediately follow a br_on_cast_fail, and probably narrows it down in the wat since nearly every use of br_on_cast fail is immediately followed by a struct.get (and there are only 33 uses of the instruction anyway).

The bytes of the failing instruction are

imhex is fucking garbage

The bytes of the failing instruction (and the instructions following) are:

FB 4F 01 00 67 8E 01
FB 03 8E 01 00

No wait I'm stupid, FB is another GC op, 0B or something is block end. So this is in fact just followed by a struct.get, to no one's surprise. Anyway, let's decode the instructions:

FB 4F ;; br_on_cast_fail
01    ;; flags: source nullable, dest not nullable
00    ;; branch to label 0
67    ;; source type: structref (ref null struct)
8E 01 ;; dest type: type 142

FB 03 ;; struct.get
8E 01 ;; type 142
00    ;; field 0

Given that we're accessing field 0, it must be this from functions 1030, 1099, or 1105:

block (result (ref null struct))
    local.get $3_IS_INTERFACE_PARAMETER
    struct.get $kotlin.Any___type_130 1
    br_on_cast_fail 1 0 struct $classITable___type_142
    struct.get $classITable___type_142 0
    ref.is_null
    i32.eqz
    br 1
end

(type $classITable___type_142 (struct
  (field (ref null $kotlin.CharSequence.itable___type_100))
  (field (ref null $kotlin.text.Appendable.itable___type_98))
  (field (ref null $kotlin.Comparable.itable___type_101))))

The error message checks out, anyway: expression has type structref but expected (ref null 142). Presumably the message here is generated by the struct.get, which would in fact specify that it wants (ref null 142) (of which (ref 142) is a subtype). But apparently it's getting structref. Sadness.

So yeah, seems like a bug.

Oy, this is just because we haven't updated to the _new_ new GC encodings that split br_on_cast into two opcodes. The nerve! I have no idea why this worked anywhere else!

This is now:

# New GC cast instruction encodings (bug 1831176)

Ok...this is weird...all the tests are passing after implementing the new encoding. ALL OF THEM. Which shouldn't be happening, since I should have to change our wat parser too. The opcode changed, after all.

Ok, the test isn't running. wtf? wasmGcEnabled() is returning false. How long has this been happening?

I think it must have been broken in bug 1832378 (https://bugzilla.mozilla.org/show_bug.cgi?id=1832378). It's very recent (two days ago).

Yeah, that was it. Ryan has a patch to fix it, but I only found out about this after independently discovering it and fixing it myself. Except not really, because apparently these macros will compile even if they make literally no sense.

Anyway...tests are failing for better reasons now, I think. I guess everything is being processed as a br_on_cast_fail now, since fb4e was introduced as a new opcode and our wast compiler isn't producing it yet. The flag bit is still there after all, we're just not actually checking one of the bits now.

## Interlude feat. the bytecode alliance

WHY DO WE HAVE TO DEAL WITH THIS SEPARATE REPO ARGH

## End of interlude

Tests are passing again after updating the bytecode alliance tooling to use the new encoding too. Just have to wait for the release and then ship it. Pausing this work for now.

Oh, note for when I come back - maybe try to preserve the flag, actually? Just in case?


Got myself a release today, integrating into our build now.

Oh no. I should have run more tests. Please tell me this is just some kind of changed syntax and not a bug in wasm-tools that will require another update cycle.

Oh no.

[x] wasm/declared-segs.js
[x] wasm/function-references/call_ref.js
[x] wasm/function-references/non-nullable.js
[x] wasm/gc/arrays.js
[x] wasm/gc/structs.js
[x] wasm/ref-types/ref-func.js
[x] wasm/ref-types/tables-multiple.js
[x] wasm/regress/bug1839065.js

Well here we go. This will be fun. All of these are syntax errors for stuff that shouldn't have changed, as far as I know.

So for element segments, maybe we have to declare the type of the element segment now? That would be reasonable.

Nope, this is just broken. Dammit. So for context, this is failing:

(func $f1)
(elem declare $f1)

The core spec states that one of the allowed abbreviations is that the element list, which is normally `{reftype} {expressions}`, can instead simply be a list of function indices, which is equivalent to `funcref (ref.func idx)...`. This all occurs after `elem declare`, so the above situation should work fine. But it's doesn't. Goddammit.

Problems with the wat parser to go fix (filling out this list as I go):

- The function-index abbreviation for element segments is not working, for any type of element segment.
-

Oh snap I think it's actually correct. I didn't notice that the function-index abbreviation requires the use of a `func` keyword first. Now, apparently that requirement is new, but it _does_ agree with the current spec. Why that is, I don't know.

It feels like maybe this is a spec gray area? For active segments in particular, you are allowed to omit the `func` keyword. I don't know why it only applies to active segments though. Clearly it wasn't required before, at least by the bytecode alliance parser. Time to go spelunking in the spec a little bit.

Ok, that's enough spelunking. Let me recap.

When you want to provide a shorthand list of func indices, you need to prefix the list with a `func` keyword like so:

(elem (table 0) (offset (i32.const 0)) func 123 234)

You can also omit the table use if you want:

(elem (offset (i32.const 0)) func 123 234)

And _specifically for active segments_ you can in this case omit the `func`:

(elem (offset (i32.const 0)) 123 234)

However, the final abbreviations simply says nothing about passive and declarative segments. The function-index abbreviation can still be used, but you need the `func`.

So we're wrong and the bytecode alliance is right.

Ok, all the element segment stuff is fixed. There are a couple other syntax situations now where I suspect we might be subtly wrong again.

Hm, this struct thing is more subtle indeed. I'll have to ask Ryan if this is a change somehow.

Yury points out that that test is actually just testing the wat parser, which we do not write or even expose to users. Test baleeted.


Ok so we're good now, right?

I should test with that Kotlin program again...yep, it works. Dunno why I didn't submit that yesterday, but whatever, it's submitted now. We'll see what the supply chain team thinks.


glandium found that the breaking changes in indexmap 2.0 were actually very minor and not even relevant to wasm-tools. Why they upgraded to 2.0 is beyond me, but it was sufficient to just patch it down to version 1.9. Hopefully this is the last thing we need to fix for this issue.


To no one's surprise, this is still ongoing. Lint problems, version problems, license problems, bleh. Whatever.

Done!
